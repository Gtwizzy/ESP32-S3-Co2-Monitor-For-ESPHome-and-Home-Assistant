esphome:
  name: co2-sensor
  friendly_name: co2-sensor
  on_boot:
    priority: 600
    then:
      - script.execute:
          id: wake_for
          duration_ms: 30000

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "AUTO GENERATED BY ESPHOME BUILD OR COMMENT OUT IF NOT USING"

ota:
  - platform: esphome
    password: "AUTO GENERATED BY ESPHOME BUILD OR COMMENT OUT IF NOT USING"
    
#If you are not using a secrets file for your Home assistant passwords or wifi credentials then you will need to replace the below with your actual wifi SSID and Password
#Set the AP SSID and Password to whatever you want. This just helps with troubleshooting if you can't access your ESPHome device for any reason and allows you a fallback to still connect to it OTA to troubleshoot wifi connections

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Co2-Sensor Fallback Hotspot"
    password: "SET TO WHATEVER YOU WANT"

captive_portal:

globals:
  - id: current_zone
    type: int
    restore_value: no
    initial_value: "0"
  - id: sleep_mode_active
    type: bool
    initial_value: "false"
  - id: display_is_on
    type: bool
    initial_value: "false"
  - id: last_event_ms
    type: uint32_t
    initial_value: "0"
  - id: animation_active
    type: bool
    initial_value: "false"
  - id: animation_frame
    type: int
    initial_value: "-1"
  - id: display_always_on
    type: bool
    initial_value: "false"
    
# These settings are based on the standard pin settings for the Waveshare ESP32-S3-LCD-1.28 NON-TOUCH version. If you intend to use the touch version the pinout is different so check it against the documentation found on the wave share wiki
# https://www.waveshare.com/wiki/ESP32-S3-LCD-1.28
# If you are using the touch version of this board or any other ESP32-S3 with an attached screen you will need to adjust these to match your exact pinout

i2c:
  id: sys_i2c
  sda: GPIO6
  scl: GPIO7
  frequency: 100kHz

spi:
  id: lcd_spi
  clk_pin: GPIO10
  mosi_pin: GPIO11

output:
  - platform: ledc
    pin: GPIO40
    id: lcd_backlight_pwm
    frequency: 2000 Hz

light:
  - platform: monochromatic
    output: lcd_backlight_pwm
    id: lcd_backlight
    default_transition_length: 0.8s
    
# ALL IMAGES SHOULD BE UPLOADED TO YOUR HOME ASSISTANT MACHINE UNDER config\esphome\co2_sensor\images You will need to create the "co2_sensor" and "images" folders for yourself as these will not exist in the standard install of HA.
# If you intend to use different background images than those shown in the git you will need to update the below values with your own image file names that you intend to use
# The images shown as "type: GRAYSCALE" are the frames specific to the animation that plays on screen wake. If you are going to change these images be aware that with this current configuration that in order tostay
# Within the flash limit of the device I have used GRAYSCALE images and am tinting them with an overlay to achieve the desired affect. Additionally 5 images used in the animation seems to be the current upper limit for the device
# Unless you change something else about the setup meaning it relies on one less image for the backgrounds or a single image for all backgrounds or something like that

image:
  - file: "co2_sensor/images/soft_and_still.png"
    id: img_soft
    type: RGB565
  - file: "co2_sensor/images/feeling_fine.png"
    id: img_fine
    type: RGB565
  - file: "co2_sensor/images/time_to_refresh.png"
    id: img_refresh
    type: RGB565
  - file: "co2_sensor/images/bring_outside_in.png"
    id: img_outside
    type: RGB565
  - file: "co2_sensor/images/lily_001.png"
    id: lily_frame_1
    type: GRAYSCALE
  - file: "co2_sensor/images/lily_002.png"
    id: lily_frame_2
    type: GRAYSCALE
  - file: "co2_sensor/images/lily_003.png"
    id: lily_frame_3
    type: GRAYSCALE
  - file: "co2_sensor/images/lily_004.png"
    id: lily_frame_4
    type: GRAYSCALE
  - file: "co2_sensor/images/lily_005.png"
    id: lily_frame_5
    type: GRAYSCALE

# You will need to place this font into your esphome directory in the config\esphome\co2_sensor\fonts that you should have already created

font:
  - file: "co2_sensor/fonts/Inter_SemiBold.ttf"
    id: ppm_font
    size: 64

text_sensor:
  - platform: template
    id: zone_stage
    name: "CO2 Sensor Air Quality Stage"
    icon: "mdi:flower-tulip"

sensor:
  - platform: scd4x
    address: 0x62
    i2c_id: sys_i2c
    update_interval: 5s
    co2:
      name: "CO2 Sensor CO2"
      id: co2_ppm
      accuracy_decimals: 0
      filters:
        - sliding_window_moving_average:
            window_size: 3
            send_every: 1
      on_value:
        then:
          - script.execute:
              id: process_co2_reading
              co2_value: !lambda 'return x;'
    temperature:
      name: "CO2 Sensor Temperature"
    humidity:
      name: "CO2 Sensor Humidity"

switch:
  - platform: template
    id: sleep_mode_switch
    name: "CO2 Sensor Sleep Mode"
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(sleep_mode_active) = true;
      - script.stop: wake_for
      - script.execute: sleep_display
    turn_off_action:
      - lambda: |-
          id(sleep_mode_active) = false;
          id(last_event_ms) = millis();
  - platform: template
    id: display_wake_switch
    name: "CO2 Sensor Display Wake"
    optimistic: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return !id(sleep_mode_active);'
          then:
            - script.execute:
                id: wake_for
                duration_ms: 15000
      - delay: 1s
      - switch.turn_off: display_wake_switch
    turn_off_action: []
  - platform: template
    id: display_always_on_switch
    name: "CO2 Sensor Display Always On"
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(display_always_on) = true;
          id(display_is_on) = true;
          id(last_event_ms) = millis();
      - script.stop: wake_for
      - light.turn_on:
          id: lcd_backlight
      - component.update: lily_display
    turn_off_action:
      - lambda: |-
          id(display_always_on) = false;
      - script.execute: sleep_display

interval:
  - interval: 60s
    then:
      - if:
          condition:
            lambda: |-
              if (id(sleep_mode_active) || id(current_zone) == 0) {
                return false;
              }
              const uint32_t HALF_HOUR = 30UL * 60UL * 1000UL;
              return (millis() - id(last_event_ms)) >= HALF_HOUR;
          then:
            - script.execute:
                id: wake_for
                duration_ms: 15000

script:
  - id: process_co2_reading
    mode: queued
    parameters:
      co2_value: float
    then:
      - lambda: |-
          const float x = co2_value;
          if (isnan(x) || id(sleep_mode_active)) {
            return;
          }
          const float T1 = 600.0f;
          const float T2 = 900.0f;
          const float T3 = 1200.0f;
          const float HYST = 20.0f;
          int zone = id(current_zone);
          auto calc_zone = [&](float val) -> int {
            if (val <= T1) return 1;
            if (val <= T2) return 2;
            if (val <= T3) return 3;
            return 4;
          };
          if (zone == 0) {
            zone = calc_zone(x);
          } else {
            switch (zone) {
              case 1:
                if (x > T1 + HYST) zone = 2;
                break;
              case 2:
                if (x > T2 + HYST) zone = 3;
                else if (x < T1 - HYST) zone = 1;
                break;
              case 3:
                if (x > T3 + HYST) zone = 4;
                else if (x < T2 - HYST) zone = 2;
                break;
              case 4:
                if (x < T3 - HYST) zone = 3;
                break;
            }
          }
          if (zone != id(current_zone)) {
            id(current_zone) = zone;
            const char *label = "";
            switch (zone) {
              case 1: label = "soft & still"; break;
              case 2: label = "feeling fine"; break;
              case 3: label = "time to refresh"; break;
              case 4: label = "bring the outside in"; break;
              default: label = "calibrating";
            }
            id(zone_stage).publish_state(label);
            id(wake_for).execute(15000);
          }
  - id: play_wake_animation
    mode: restart
    then:
      - lambda: |-
          id(animation_active) = true;
          id(animation_frame) = 0;
      - component.update: lily_display
      - repeat:
          count: 4
          then:
            - delay: 120ms
            - lambda: |-
                id(animation_frame)++;
            - component.update: lily_display
      - delay: 200ms
      - lambda: |-
          id(animation_active) = false;
          id(animation_frame) = -1;
      - component.update: lily_display
  - id: sleep_display
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(display_is_on) && !id(display_always_on);'
          then:
            - light.turn_off: lcd_backlight
            - lambda: |-
                id(display_is_on) = false;
  - id: wake_for
    mode: restart
    parameters:
      duration_ms: int
    then:
      - if:
          condition:
            lambda: 'return id(sleep_mode_active);'
          then:
            - script.execute: sleep_display
          else:
            - lambda: |-
                id(display_is_on) = true;
                id(last_event_ms) = millis();
            - light.turn_on:
                id: lcd_backlight
            - script.execute: play_wake_animation
            - if:
                condition:
                  lambda: 'return !id(display_always_on);'
                then:
                  - delay: !lambda "return duration_ms;"
                  - script.execute: sleep_display

display:
  - platform: ili9xxx
    model: GC9A01A
    invert_colors: true
    cs_pin: GPIO9
    dc_pin: GPIO8
    reset_pin: GPIO12
    spi_id: lcd_spi
    id: lily_display
    lambda: |-
      it.fill(Color::BLACK);
      auto zone = id(current_zone);
      if (zone == 0) zone = 1;
      if (id(animation_active) && id(animation_frame) >= 0) {
        static const Color tint_colors[] = {
          Color(0xDB, 0x8E, 0x4A),
          Color(0xC5, 0xBB, 0x64),
          Color(0x28, 0x80, 0x48),
          Color(0x4C, 0xCD, 0x9D),
          Color(0x5C, 0xC5, 0xD2)
        };
        int frame_index = id(animation_frame);
        if (frame_index < 0) frame_index = 0;
        if (frame_index > 4) frame_index = 4;
        const esphome::image::Image *frame = nullptr;
        switch (frame_index) {
          case 0: frame = id(lily_frame_1); break;
          case 1: frame = id(lily_frame_2); break;
          case 2: frame = id(lily_frame_3); break;
          case 3: frame = id(lily_frame_4); break;
          case 4: frame = id(lily_frame_5); break;
        }
        if (frame == nullptr) {
          return;
        }
        Color tint = tint_colors[frame_index];
        const int width = frame->get_width();
        const int height = frame->get_height();
        for (int y = 0; y < height; y++) {
          for (int x = 0; x < width; x++) {
            auto px = frame->get_pixel(x, y);
            uint8_t intensity = px.red;
            if (intensity == 0) {
              continue;
            }
            uint8_t r = (tint.red * intensity) / 255;
            uint8_t g = (tint.green * intensity) / 255;
            uint8_t b = (tint.blue * intensity) / 255;
            it.draw_pixel_at(x, y, Color(r, g, b));
          }
        }
        return;
      }
      auto *bg = &id(img_soft);
      Color accent(0x44, 0xD1, 0xC1);
      switch (zone) {
        case 1:
          bg = &id(img_soft);
          accent = Color(0x44, 0xD1, 0xC1);
          break;
        case 2:
          bg = &id(img_fine);
          accent = Color(0x63, 0xD1, 0x54);
          break;
        case 3:
          bg = &id(img_refresh);
          accent = Color(0xD4, 0x93, 0x33);
          break;
        case 4:
          bg = &id(img_outside);
          accent = Color(0x9B, 0x4A, 0xB5);
          break;
      }
      it.image(0, 0, *bg);
      if (!isnan(id(co2_ppm).state)) {
        char buffer[8];
        snprintf(buffer, sizeof(buffer), "%.0f", id(co2_ppm).state);
        it.printf(120, 102, id(ppm_font), accent, TextAlign::CENTER, "%s", buffer);
      } else {
        it.printf(120, 102, id(ppm_font), accent, TextAlign::CENTER, "---");
      }
